This is an ad-hoc memo. Detailed documentation is to be found as Javadoc. You can rebuild it with `gradle javadoc`.

# Core system overview

Any running job is animated by the same core. Typically the app's entry point will be the CLIApp, in the hamster.CLI package. The CLIApp will instanciate one of its tasks, depending on the command-line options. The most important tasks will in turn instanciate one of the startup classes from the hamster.startup package. A startup class will set up the core components to run the job.

The core components revolve around two central hinges, and two main data types. The hinges are :

* a configuration object (talked to as an IConfiguration) that can answer any question about *what should be done*. It embeds what is basically an interpreter pattern, which in a normal situation is built according to the user's plain text configuration. Once set up, every call to a method of the configuration object always gives the same answer when provided with the same parameters. In that sense, the configuration object is "purely functional".

* a mediator object (talked to as an IMediator) that keeps track of the changing state of the application. Its primary role is to pipe elements (links and contents) between the workers. To this effect, the main implementation is built around a set of blocking queues, as well as lists and sets that keep track of the current job's exact state. The secondary roles include the ability to save that state into a serializable object, that can be written to a file and used later on to recover an interrupted job, or to recycle a job's failed downloads that look like they may be worth retrying.

The main data types are :

* Link : essentially an URL, with a bit of added information. Links are produced by analyzing downloaded contents.

* Content : essentially a raw array of bytes, with a bit of added information too, first of which its source link. Contents are produced by DownloadWorkers, and then analyzed and modified by the ProcessingWorkers to extract relevant links and change HTML attributes to keep the whole site consistent with its new local layout.

The rest is pretty straightforward.

![Hamster core](https://raw.githubusercontent.com/mdolidon/hamster/master/dev_docs/core_components.png)


# Setting it up for Eclipse

`gradle eclipse` and then import as an Eclipse project.

I'll let you adapt for other IDEs. Pull requests are welcome.

# Building the main JAR

`gradle shadowJar`

The output lives in `build/libs/hamster-all.jar`

# Changing the config DSL's parser

For now I keep this separate. The setup is not automated. It's in `configGrammar/`. Make sure you download http://www.antlr.org/download/antlr-4.7.1-complete.jar and drop it in there. As Gradle needs about 30 seconds to do anything of interest on my low-end NUC, Make is good enough for me on this part that's not so often touched. 

`make` builds Java files locally from the grammar, builds class files in a test directory, and runs the new parser on `test_hamster_config.txt`

`make deploy` updates the main source tree, in the autogenerated package : org.mdolidon.hamster.configuration.antlrGenerated

`make clean`, obviously.

Feel free if you want to gradleize this. However, as I said, I'll stick with Make because of sheer comfort on my dev box.

# Tests

I like to run JUnit tests from Eclipse, but you may prefer `gradle test`.
